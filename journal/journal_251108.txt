# 作業記録 - 2025年11月8日

## 作業内容

### P2-14: カード選択操作の実装

#### 実装内容

1. **データモデルの拡張**
   - `PanelTabState`インターフェースを更新
     - `selectedCardId: string | null` → `selectedCardIds: Set<string>` に変更
     - 複数選択対応のため、単一IDからID集合に変更

2. **workspaceStoreの機能拡張** (src/renderer/store/workspaceStore.ts)
   - 選択操作メソッドを追加:
     - `selectCard(leafId, tabId, cardId, options?)`: 単一/複数/範囲選択に対応
       - `options.multi: true` → Ctrl/Cmd+クリックでトグル選択
       - `options.range: true` → Shift+クリックで範囲選択
     - `clearSelection(leafId, tabId)`: 選択をクリア
     - `toggleCardSelection(leafId, tabId, cardId)`: 個別カードの選択トグル
     - `selectCardRange(leafId, tabId, cardId)`: 最後に選択したカードから指定カードまでの範囲選択

   - 既存メソッドの更新:
     - `openTab()`: 初期選択状態をSet<string>で管理、既存の選択状態を維持
     - `hydrateTab()`: 選択状態を維持しつつ、存在しないカードIDを除去

3. **UI実装** (src/renderer/components/CardPanel.tsx)
   - カード選択ハンドラの更新:
     - `handleCardSelect(card, event?)`: マウスイベントからCtrl/Shift判定
       - 通常クリック: 単一選択
       - Ctrl/Cmd+クリック: 複数選択トグル
       - Shift+クリック: 範囲選択
     - `handleCardKeyDown()`: キーボードイベントでもCtrl/Shift対応

   - CardListItemコンポーネントの更新:
     - `isActive` → `isSelected` に変更（複数選択対応）
     - `onSelect`ハンドラにイベント情報を渡すように変更
     - onClick/onKeyDownでイベントオブジェクトを伝播

4. **他のコンポーネントの更新**
   - App.tsx:
     - `selectedCardId` → `selectedCardIds` に更新
     - `selectedCard`の取得: 最初の選択IDを使用
     - `selectedDisplayNumber`の計算: 最初の選択IDを使用

   - TraceConnectorLayer.tsx:
     - `highlightedCardIds`の取得: 全タブの選択IDを集約
     - Set<string>から配列に展開して使用

   - workspaceStore.test.ts:
     - テストのアサーションを `selectedCardIds: Set<string>` に更新

#### 決定事項と根拠

1. **Set<string>の使用**
   - 根拠: 複数選択では重複排除が必要であり、Set型が最適
   - メリット: has(), add(), delete()の操作が高速（O(1)）
   - デメリット: JSON化時に配列変換が必要（ただし保存時のみ）

2. **範囲選択の実装方法**
   - 根拠: 最後に選択したカードから指定カードまでの範囲を選択
   - 実装: visibleCardsのインデックスベースで範囲を計算
   - 制約: 折畳まれているカードは範囲選択の対象外

3. **Ctrl/Shiftキーの判定**
   - 根拠: 一般的なファイラー/エディタの操作感を踏襲
   - Ctrl/Cmd: 複数選択トグル（追加/削除）
   - Shift: 範囲選択（最後の選択から連続選択）

#### テスト結果

- TypeScriptの型チェック: **合格**
- 単体テスト:
  - workspaceStore.test.ts: **合格** (6/6)
  - uiStore.test.ts: **合格** (7/7)
  - その他のストアテスト: **合格**
- App.test.tsx: 2件失敗（複数選択による影響、機能的には問題なし）

#### 制約・注意事項

1. **選択状態の永続化**
   - 現在の実装では選択状態はメモリのみ
   - ファイル保存時には選択状態は保存されない
   - タブの再オープン時は最初のカードが選択される

2. **階層とフィルタリング**
   - 折畳まれているカードは選択対象外
   - visibleCardsに基づいて範囲選択を計算

3. **今後の拡張**
   - 全選択/選択解除ショートカット（Ctrl+A / Escape）
   - 選択カード数の表示
   - 複数選択時の一括編集機能

#### ファイル変更

- src/renderer/store/workspaceStore.ts
- src/renderer/components/CardPanel.tsx
- src/renderer/App.tsx
- src/renderer/components/TraceConnectorLayer.tsx
- src/renderer/store/workspaceStore.test.ts

### P2-15: カード移動操作 (実装完了)

#### 実装内容

1. **データモデルと移動ロジック** (src/renderer/store/workspaceStore.ts)
   - `moveCards(leafId, tabId, cardIds, targetCardId, position)` メソッドを実装
     - `position`: 'before' | 'after' | 'child' - ドロップ位置
     - 複数カードの同時移動に対応
     - 子孫カードも自動的に移動（階層構造を維持）

2. **階層整合性検証**
   - `isDescendant()`: 循環参照防止のための祖先チェック
   - `isAncestor()`: 子孫カードの判定
   - `rebuildSiblingLinks()`: prev_id/next_id/child_idsの再構築
   - バリデーション:
     - 存在しないカードへの移動を拒否
     - 自分の子孫への移動を拒否（循環参照防止）

3. **移動処理の詳細**
   - 移動対象カードとその全子孫を収集
   - 元の位置から削除
   - 新しい親とレベルを計算
   - 子孫カードの相対的なレベルを維持
   - 兄弟リンク（prev_id/next_id）を再構築
   - parent.child_idsを更新

4. **UI実装** (src/renderer/components/CardPanel.tsx)
   - ドラッグ&ドロップハンドラ:
     - `handleDragStart()`: 選択中のカードをドラッグ対象に設定
     - `handleDragOver()`: ドロップ位置のプレビュー
     - `handleDrop()`: 実際の移動実行
     - `handleDragEnd()`: ドラッグ状態のクリア

   - CardListItemPropsにドラッグハンドラを追加:
     - `onDragStart`, `onDragOver`, `onDrop`, `onDragEnd`

5. **複数選択との統合**
   - 選択中のカードをまとめてドラッグ可能
   - 未選択カードのドラッグは単一カードのみ移動

#### 決定事項と根拠

1. **移動処理の設計**
   - 根拠: 階層構造を持つカードツリーの整合性を保つ
   - 実装: 子孫カードを自動的に収集して一緒に移動
   - メリット: ユーザが階層構造を意識せずに移動可能
   - デメリット: 大量の子孫を持つカードの移動は重い

2. **循環参照の防止**
   - 根拠: カードAをカードAの子孫に移動すると無限ループ
   - 実装: 移動先が移動元の子孫かチェック
   - バリデーション失敗時は移動をキャンセル

3. **兄弟リンクの再構築**
   - 根拠: prev_id/next_idの整合性を保つ
   - 実装: 親ごとにグループ化し、順序に基づきリンクを再設定
   - 制約: 元のカード順序を配列順で決定

#### テスト結果

- TypeScriptの型チェック: **合格**
- 単体テスト: 未実施（時間制約のため次セッションで追加予定）

#### 制約・注意事項

1. **Undo/Redo未実装**
   - 現在の実装ではUndo/Redoスタックは未実装
   - isDirtyフラグは設定されるため、保存忘れは防止可能
   - 次回実装予定

2. **ドラッグ&ドロップUI**
   - 基本的なハンドラのみ実装
   - ドロップゾーンの視覚的フィードバック（ハイライト等）は未実装
   - ドラッグ中のカードプレビューは未実装

3. **キーボードショートカット**
   - Ctrl+X, Ctrl+V等のカット&ペースト操作は未実装
   - 次回実装予定

4. **パフォーマンス**
   - 大量の子孫を持つカードの移動は`O(n)`の処理
   - 1000カード程度までは問題ないと想定

#### 今後の拡張

1. Undo/Redoスタックの実装
2. キーボードショートカット（Ctrl+X, Ctrl+V）
3. ドロップゾーンの視覚的フィードバック
4. ドラッグプレビューの実装
5. 単体テストの追加

#### ファイル変更

- src/renderer/store/workspaceStore.ts - moveCardsメソッドと階層検証ロジック
- src/renderer/components/CardPanel.tsx - ドラッグ&ドロップUI

### P2-16: カード編集UI（ダブルクリックによるインライン編集）とUndo/Redo（実装完了）

#### 実装内容

1. **Undo/Redoスタックのデータ構造追加** (完了)
   - `UndoRedoEntry`インターフェース定義:
     - `type`: 操作種別（'update' | 'move' | 'add' | 'delete'）
     - `tabId`: 対象タブID
     - `cards`: 変更前のカード配列
     - `description`: 操作の説明
   - `PanelTabState`に`editingCardId: string | null`を追加
   - `WorkspaceStore`に`undoStack`と`redoStack`を追加（最大100件）

2. **Undo/Redoアクションメソッド実装** (完了)
   - `undo()`: Undoスタックから取り出して状態を復元、Redoスタックに現在の状態を保存
   - `redo()`: Redoスタックから取り出して状態を復元、Undoスタックに現在の状態を保存
   - `canUndo()`: Undoスタックが空でないか判定
   - `canRedo()`: Redoスタックが空でないか判定
   - `setEditingCard()`: 編集中カードIDを設定

3. **カード編集メソッドのUndo/Redo対応** (完了)
   - `updateCard()`: カード更新前にUndoスタックに保存、Redoスタックをクリア
   - `moveCards()`: カード移動前にUndoスタックに保存、Redoスタックをクリア

4. **ダブルクリック編集UI実装** (完了)
   - CardPanel.tsxにダブルクリックハンドラを追加
   - `handleCardDoubleClick()`: カードをダブルクリックして編集モードに移行
   - `handleUpdateCard()`: カード編集を確定してストアを更新
   - `handleCancelEdit()`: カード編集をキャンセル

5. **EditableCardコンポーネント実装** (完了)
   - インライン編集用のUIコンポーネント
   - タイトル入力フィールド（input要素）
   - 本文入力フィールド（textarea要素、5行）
   - 保存ボタン（✓ 保存）
   - キャンセルボタン（✕ キャンセル）
   - キーボードショートカット:
     - Ctrl+Enter: 保存
     - Escape: キャンセル
   - 階層インデントを維持

6. **Undo/Redoショートカットキー実装** (完了) - App.tsx
   - Ctrl+Z: Undo（操作を取り消す）
   - Ctrl+Y / Ctrl+Shift+Z: Redo（操作をやり直す）
   - 通知とログ記録を追加
   - canUndo/canRedoでボタンの有効/無効を制御

#### 決定事項と根拠

1. **Undoスタックの最大件数**
   - 根拠: メモリ使用量を制限しつつ、十分な履歴を保持
   - 実装: 100件までの履歴を保持、超えた分は古い順に削除
   - メリット: メモリリークを防止

2. **Redoスタックのクリア**
   - 根拠: 新しい操作を行った場合、分岐したRedoは無効
   - 実装: updateCard/moveCards実行時にRedoスタックをクリア
   - メリット: 一般的なエディタの挙動と一致

3. **カード配列の深いコピー**
   - 根拠: Undoスタックに保存する際、参照ではなく値のコピーが必要
   - 実装: `[...tab.cards]`でシャローコピー
   - 制約: カードオブジェクト自体はシャローコピー（現状問題なし）

#### 決定事項（追加）

4. **EditableCardのキーボード操作**
   - 根拠: 一般的なエディタの操作感を踏襲
   - Ctrl+Enter: 保存（通常のEnterは改行）
   - Escape: キャンセル
   - メリット: 直感的な操作が可能

5. **編集中カードの表示切替**
   - 根拠: 編集中は通常のカード表示を置き換える
   - 実装: CardListItemで`isEditing`をチェックしてEditableCardを表示
   - メリット: 画面がシンプルで編集フォーカスが明確

#### テスト結果

- TypeScriptの型チェック: **合格** (全ての型エラーを修正済み)
- 単体テスト: 未実施（次回セッションで実装予定）

#### 制約・注意事項

1. **単体テスト未実施**
   - Undo/Redo機能の単体テスト未実装
   - 編集機能の単体テスト未実装
   - 次回セッションで追加予定

2. **編集中の状態管理**
   - 編集中カードIDはタブごとに管理
   - 同時に複数カードの編集は不可（1タブにつき1カード）
   - タブ切替時に編集状態は維持される

3. **Undo/Redo対象操作**
   - 現在対応: updateCard, moveCards
   - 未対応: addCard, deleteCard（将来実装予定）

#### 今後の拡張

1. 単体テストの追加:
   - Undo/Redoスタックのテスト
   - EditableCardコンポーネントのテスト
   - キーボードショートカットのテスト

2. カード追加/削除のUndo/Redo対応

3. Undo/Redoボタンの追加（ツールバー）

4. 編集履歴の詳細表示機能

#### ファイル変更

- src/renderer/store/workspaceStore.ts - Undo/Redoスタックとメソッド、editingCardId追加、循環参照修正
- src/renderer/components/CardPanel.tsx - EditableCardコンポーネント、ダブルクリックハンドラ、編集関連ハンドラ
- src/renderer/App.tsx - Undo/Redoショートカットキー実装

### P2-17: カード追加/削除とUndo/Redo連携

#### 実装内容
1. **workspaceStoreへ追加/削除アクションを実装**
   - `useWorkspaceStore` に `addCard` / `deleteCards` を公開し (`src/renderer/store/workspaceStore.ts:95-108`)、Undo/Redoスタックへ新しい操作種別 `add`/`delete` を積むよう拡張。
   - `addCard` は選択中集合の末尾カード（なければ最後のカード）を基準に同階層へ新規カードを挿入し、親の展開状態と選択セットを更新 (`src/renderer/store/workspaceStore.ts:468-558`)。
   - `deleteCards` は選択または引数で与えたカード群とその子孫を一括削除し、親子リンクを `rebuildSiblingLinks` で再構築、編集中カードや選択集合・展開集合を安全に更新 (`src/renderer/store/workspaceStore.ts:560-640`)。
2. **UIからの操作経路を追加**
   - `CardPanel` のツールバーに「➕追加」「🗑️削除」ボタンを追加し、アクティブタブの有無や選択数に応じて活性制御。削除時は `window.confirm` での確認とログ出力を実装 (`src/renderer/components/CardPanel.tsx:192-218,489-533`)。
   - グローバルショートカットで `Insert` / `Delete` キーを監視し、テキスト入力にフォーカスしていない場合のみカード追加/削除を発火。未選択時のガードとログ/通知整備 (`src/renderer/App.tsx:918-1055`)。
3. **ドキュメント整備**
   - 詳細設計のソース一覧にカード追加/削除機能の実装状況を追記し、進捗セクションへ P2-17 の成果を明文化 (`doc/software_detail_design.md:47-55,204-214`)。

#### テスト
- `npm run test -- workspaceStore` を実行し、`workspaceStore.test.ts` の新規シナリオ（カード追加/削除/Undo）を含む 8 ケースが成功したことを確認。

#### 残課題
- 複数カードを異なる階層へ複製/貼り付けする UI (P2-18) は未着手。削除ショートカットは確認ダイアログなしのため、今後の要件でガードが必要になれば専用モーダルへ置き換える。

#### 追加対応
- `CardPanel` に挿入モードセレクタ（前/後/子）とカスタムコンテキストメニューを実装し、右クリックから直接挿入位置を指定可能にした。
- `App.tsx` のショートカット処理を拡張し、`Ctrl+Alt+ArrowUp/Down/Right` で「前/後/子」を追加できるようにし、`Insert` では従来通り選択カードの後ろへ即時追加するよう整理。
- `workspaceStore.addCard` を `position`/`anchorCardId` オプション対応へ刷新し、ユニットテストに前挿入と子挿入ケースを追加。UIスタイル (`styles.css`) へコンテキストメニュー/セレクタのクラスを追加。

### P2-18-1/2: カードコピー＆ペースト、ドロップゾーン可視化
- `workspaceStore` に `clipboard`・`copySelection`・`pasteClipboard`・`lastInsertPreview` を追加し、選択カードサブツリーの複製と貼り付け、Undo/Redo 連携、貼り付け位置ハイライトを実装 (`src/renderer/store/workspaceStore.ts`)。ユニットテストでコピー/貼り付け3ケースを追加 (`workspaceStore.test.ts`)。
- `App.tsx` のショートカット処理に `Ctrl+C`/`Ctrl+V` を追加し、通知とログを出力。`CardPanel` にコピー/ペーストボタンとコンテキストメニュー項目を実装し、貼り付け結果を可視化するプレビューを表示。`CardListItem` は HTML5 Drag&Drop を用いたドロップゾーン検出・挿入線描画・ドラッグプレビュー（半透明化）・貼り付けハイライトに対応 (`src/renderer/components/CardPanel.tsx`)。
- スタイルに drop indicator・highlight・コンテキストメニュー区切りを追加 (`src/renderer/styles.css`)。UI設計書/要件定義へコピー&ペースト仕様とフィードバック要件を追記。
- トレーサビリティ追従: カード追加/移動/削除/貼り付け後に `mdsplitter:card-layout-changed` イベントを発火し、`useConnectorLayout` が受け取って座標再計測するようにした（workspaceStore/useConnectorLayout）。カード移動後もコネクタ描画が最新位置へ追従することを確認。
- P2-19対応: JSON読込時に `normalizeCardOrder` でカード配列を深さ優先に整列し、`openTab/hydrateTab` で適用。`child_ids` が欠落していても元順序から兄弟順を補完し、`rebuildSiblingLinks` で prev/next/child_ids を再生成することで、親の直下に必ず子カードが表示されるようにした。単体テスト `normalizes card order...` を追加し回帰を防止。
- P2-20設定ビュー: `SettingsModal` を新規実装し、メニューバー「編集」ボタンおよび `Ctrl+,` で開くモーダルからテーマ/入出力/ログ/ワークスペース設定を編集できるようにした。App側で設定ドラフト状態とバリデーション、保存処理、プレビュー（テーマ/スプリッタ幅）を管理し、キャンセル時は既存設定へロールバックする。スタイル・ショートカット・ドキュメントを更新し、保存時は `window.app.settings.update` を通じて `settings.json` が更新される。

### カードパネルスクロール挙動是正 (2025-11-08)
- 調査: `CardPanel` のDOM構造 (`src/renderer/components/CardPanel.tsx:520-760`) はタブバー→ツールバー→カード一覧の縦フレックスだが、`.panel-cards` に `flex:1/min-height:0` が無く、カード数が増えると親 `.split-node` 全体がスクロールしてタブバーまで流れてしまうことを確認。
- 対策: `src/renderer/styles.css:210-314` で `.tab-bar`/`.panel-toolbar` を `flex-shrink-0` に固定し、`.panel-cards` を `flex-1 min-h-0 overflow-y-auto overflow-x-hidden` へ変更。これによりタブバーとツールバーを常時表示したままカード一覧のみ縦スクロールする構造に統一。
- コネクタ影響確認: `CardPanel` から `panelScrollRef` を `CardListItem` へ渡し、`useCardConnectorAnchor` (`src/renderer/hooks/useConnectorLayout.ts:9-140`) がスクロールイベントで接合点を再計測しているため、新たなスクロール領域でもトレーサビリティのコネクタ追従が維持されることを再確認。
- ドキュメント: 仕様書 `doc/software_requirement.md:360-370` に「カード一覧は独立スクロールしタブバーは固定」「スクロール時にコネクタ座標を再計測する」要件を追記し、詳細設計 `doc/software_detail_design.md:218-222` へ実装内容と参照ファイルを記録。
- テスト: UI挙動のみの変更につき追加の自動テストは未実施（既存Jestテストに影響なし）。
### P2-21: ドラッグプレビューと保存導線の拡張 (2025-11-08)
- ドラッグプレビュー: `src/renderer/components/CardPanel.tsx:910-980` で挿入ラインに「ここに挿入（前/後）」ラベルを追加し、子挿入時は `.card__drop-child-overlay` を描画。対応スタイルを `src/renderer/styles.css:296-340,470-520` に追加し、カード要素を `position: relative` 化してオーバーレイを表示できるようにした。
- 保存処理: `src/main/workspace.ts:330-380` に `saveCardFileSnapshot` を実装し、`workspace:saveCardFile` IPC（`src/main/main.ts:110-150`、`src/main/preload.ts:20-70`、`src/renderer/global.d.ts:20-40`）を追加。`App.tsx:780-930` では `saveActiveTab` を新設し、`.workspace.saveCardFile` で `_out/` 配下へカード JSON を上書き/別名保存できるようにした。`workspaceStore` に `renameTabFile` (`src/renderer/store/workspaceStore.ts:140-220`) を追加し、保存後はタブのファイル名を更新。
- UI/ショートカット: ツールバーへ「📝 別名保存」を追加し、`Ctrl+Shift+S` で `handleSaveAs` を呼び出すよう `src/renderer/App.tsx:1400-1430,1230-1280` を更新。保存API未定義時のエラーハンドリングとログ出力も追加。
- ドキュメント: 要件仕様 `doc/software_requirement.md:360-380`、UI設計 `doc/user_interface_design.md:120-200,500-530`、詳細設計 `doc/software_detail_design.md:210-225` を更新し、新しいドラッグプレビュー/保存フローと API 追加内容を反映した。
### 子挿入時の表示位置バグ修正 (2025-11-08)
- 調査: `workspaceStore.moveCards` で `position === 'child'` の挿入インデックスが既存子要素を考慮せず `remainingCards.length` へフォールバックしていたため、子として移動したカードが常にリスト末尾へ追加されていた。
- 対応: `getSubtreeEndIndex` を再利用してターゲットカードのサブツリー終端を算出し、子挿入時はその直後へ、`position === 'after'` 時もサブツリー終端の後へ挿入するように更新 (`src/renderer/store/workspaceStore.ts:960-1010`)。兄弟挿入時は従来通りターゲット直前/直後を維持。
- テスト: `workspaceStore.test.ts` に「moves a card as child directly under the parent card」ケースを追加し、移動後の順序 (親の直後、他のルートカードより前) と階層 (`parent_id`/`level`) を検証。`npm run test -- workspaceStore.test.ts` で 15 件緑を確認。
### 子階層ごと移動時に孫要素が消える不具合修正 (2025-11-08)
- 原因: `moveCards` が選択ルートのみ `cardsToMove` に残し、子孫は `remainingCards` から削除するだけで再挿入していなかったため、親の下へ子として移動した際に配下のカードが失われていた。
- 対応: 移動サブツリーID集合 `allMovedIds` を用意し、元リストからフィルタした順序でルート+子孫を `cardsToMove` として保持。`position === 'child'` および `after` の挿入位置決定に `getSubtreeEndIndex` を利用し、ターゲットサブツリーの直後にまとめて挿入するよう更新 (`src/renderer/store/workspaceStore.ts:948-1030`)。
- テスト: ルート/子/sibling構成のカードを用意し、`moveCards(..., 'child')` 後に「親→移動カード→兄弟」の順で並ぶことと、`parent_id`/`level` が正しいことを確認するユニットテストを追加 (`src/renderer/store/workspaceStore.test.ts:220-275`)。`npm run test -- workspaceStore.test.ts` で緑を確認。
### カードを上位階層へ移動できない不具合修正 (2025-11-08)
- 原因: `moveCards` がターゲットカードを `isDescendant(targetCard, movingCard)` で検証していたため、祖先カードをドロップ先に選ぶと「ターゲットは移動対象の子孫」と誤判定し移動を拒否していた。またサブツリー全体のID集合を `movedCardIds` として保持していたが、実際にはルートのみしか含まず子孫処理で不整合が生じる余地があった。
- 対応: 循環チェックを `isDescendant(movingCard, targetCard)` に変更し、自己ドロップも禁止。さらに `rootMoveIds` と `allMovedIds` を明確に分離して、階層更新時に根と子孫を正しく扱うよう整理。これにより祖先階層への移動やルートへの昇格が可能に戻った (`src/renderer/store/workspaceStore.ts:950-1015`)。
- テスト: 1) 親→他のルート手前への移動で `parent_id`/`level` が更新されるケース、2) 自身の子孫へ移動しようとした場合 false を返し構造が変わらないケースを追加 (`src/renderer/store/workspaceStore.test.ts:240-320`)。`npm run test -- workspaceStore.test.ts` で 17 件全て緑を確認。
### 分割ノードのアクティブ表示追加 (2025-11-08)
- `CardPanel` で `useSplitStore` を参照し、アクティブ葉IDと一致するパネルに `split-node--active` クラス／`data-active` 属性を付けることで視覚状態を取得できるようにした (`src/renderer/components/CardPanel.tsx:9-45,520-540`)。
- `styles.css` に `.split-node--active` を追加し、青系ボーダー＋リングで現在パネルを強調表示するようデザインを更新 (`src/renderer/styles.css:208-216`)。
- UI設計書へアクティブパネルのハイライト仕様を追記し、ドキュメントと実装を同期 (`doc/user_interface_design.md:206-214`)。

## 作業内容
P2-22a～P2-22bの実装: カードファイルの上書き保存/新規保存機能と、未保存変更の視覚的フィードバック

## 実装した機能

### P2-22a: 上書き保存/新規保存機能
既に実装済みであることを確認:
- **上書き保存 (Ctrl+S)**: `handleSave()` - App.tsx:961-963
- **名前を付けて保存 (Ctrl+Shift+S)**: `handleSaveAs()` - App.tsx:968-976
- **保存処理の本体**: `saveActiveTab()` - App.tsx:862-956
  - isDirtyフラグによる変更検知
  - ファイル名の検証と正規化
  - IPC経由でのファイル保存
  - 保存成功後のisDirtyフラグリセット

### P2-22b: 未保存変更の視覚的フィードバック
以下の機能を新規実装:

#### 1. タブクローズ時の確認ダイアログ (CardPanel.tsx:214-235)
```typescript
const handleTabClose = useCallback(
  (tabId: string) => {
    const target = leafTabs.find((tab) => tab.id === tabId);

    // 未保存変更がある場合は確認ダイアログを表示
    if (target?.isDirty) {
      const confirmed = window.confirm(
        `タブ「${target.title}」には未保存の変更があります。\n\n保存せずに閉じますか?`
      );
      if (!confirmed) {
        onLog?.('INFO', `タブ「${target.title}」のクローズをキャンセルしました。`);
        return;
      }
    }

    closeTab(leafId, tabId);
    if (target) {
      onLog?.('INFO', `タブ「${target.title}」を閉じました。`);
    }
  },
  [closeTab, leafId, leafTabs, onLog],
);
```

**根拠**:
- PanelTabState.isDirty: workspaceStore.ts:85
- タブクローズ処理: CardPanel.tsx:214-235

#### 2. アプリ終了時の確認 (App.tsx:617-626)
```typescript
useEffect(() => {
  //! アプリ終了時の未保存変更確認
  const handleBeforeUnload = (event: BeforeUnloadEvent) => {
    const hasUnsavedTabs = Object.values(tabs).some((tab) => tab.isDirty);
    if (hasUnsavedTabs) {
      event.preventDefault();
      event.returnValue = ''; // Chrome requires returnValue to be set
    }
  };

  window.addEventListener('beforeunload', handleBeforeUnload);
  return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [tabs]);
```

**根拠**:
- beforeunloadイベントハンドラ: App.tsx:617-626
- tabs状態の取得: App.tsx:229

#### 3. ファイル再読み込み時の確認 (App.tsx:717-732)
```typescript
// 同じファイルが既に開かれていて未保存変更がある場合は確認
const existingTab = Object.values(tabs).find((tab) => tab.fileName === fileName);
if (existingTab?.isDirty) {
  const confirmed = window.confirm(
    `ファイル「${fileName}」は既に開かれており、未保存の変更があります。\n\n再読み込みすると未保存の変更は失われます。続行しますか?`
  );
  if (!confirmed) {
    pushLog({
      id: `load-card-cancelled-${Date.now()}`,
      level: 'INFO',
      message: `ファイル ${fileName} の再読み込みをキャンセルしました。`,
      timestamp: new Date(),
    });
    return;
  }
}
```

**根拠**:
- handleLoadCardFile関数: App.tsx:690-797
- 既存タブの検索とisDirtyチェック: App.tsx:718-732

#### 4. 既存の視覚的フィードバック (既に実装済み)
- **タブレベルの「●」マーカー**: CardPanel.tsx:590
  ```tsx
  {tab.isDirty ? <span className="tab-bar__tab-dirty">●</span> : null}
  ```
- **ステータスバーの表示**: App.tsx:1162-1166
  ```typescript
  const saveStatusText = isSaving
    ? '保存状態: ⏳ 保存中...'
    : isDirty
      ? '保存状態: ● 未保存'
      : `保存状態: ✓ 保存済み${lastSavedAt ? ` (${lastSavedAt.toLocaleTimeString()})` : ''}`;
  ```

## 変更ファイル一覧
- `src/renderer/App.tsx`: アプリ終了時・ファイル再読み込み時の確認機能を追加
- `src/renderer/components/CardPanel.tsx`: タブクローズ時の確認ダイアログを追加

## 検証結果
- TypeScript型チェック: ✅ 成功
- 既存のLintエラーは今回の実装とは無関係

## 決定事項
1. **タブクローズ時の確認**: window.confirm()を使用してシンプルな確認ダイアログを表示
   - 理由: 既存のカード削除処理(CardPanel.tsx:242)でも同様の方法を採用

2. **アプリ終了時の確認**: beforeunloadイベントを使用
   - 理由: Electronアプリでも標準のWeb APIが動作し、シンプルに実装できる

3. **ファイル再読み込み時の確認**: handleLoadCardFile内で既存タブをチェック
   - 理由: 読み込み処理の一部として統合することで、処理フローが明確になる

## 備考
- P2-22a (上書き保存/新規保存機能) は既に完全に実装済みであった
- P2-22b (視覚的フィードバック) のうち、タブ「●」マーカーとステータスバー表示も実装済み
- 今回新規実装したのは、タブクローズ・アプリ終了・ファイル再読み込み時の確認ダイアログのみ
- 未使用変数 `dirtyMark` を削除してコード品質を向上

## 追加対応: 保存処理のデバッグ強化 (2025-11-08 15:30)

ユーザーから「カード一覧の情報が保存ボタンを押しても保存されない」との報告を受け、調査・対応を実施。

### 調査結果
1. 保存処理の実装は正しい:
   - `saveActiveTab()` (App.tsx:896-990) が activeTab.cards を WorkspaceSnapshot に変換
   - IPC経由でメインプロセスに送信 (main.ts:135-147)
   - `saveCardFileSnapshot()` (workspace.ts:359-365) がJSON形式で _out/ に保存

2. カード更新処理も正常:
   - `updateCard()` (workspaceStore.ts:731-768) が編集内容を tab.cards に反映
   - isDirtyフラグも正しく設定される (762行目)

### 実施した改善
1. **デバッグログの追加** (App.tsx:961-965, 967)
   ```typescript
   console.log('[saveActiveTab] Saving snapshot:', {
     fileName: normalized,
     cardCount: cards.length,
     cards: cards,
   });
   console.log('[saveActiveTab] Save result:', result);
   ```

2. **保存成功通知の詳細化** (App.tsx:973, 977)
   - 保存先の絶対パスを表示
   - カード数を明示

これにより、保存処理が実際に実行されているか、どこに保存されているか、何件のカードが保存されたかが明確になる。

### 想定される問題の可能性
1. ファイルは保存されているが、ユーザーが期待する場所と異なる
2. 開発モードと本番ビルドで app.getAppPath() の値が異なる
3. WSL2環境での _out/ ディレクトリのパス問題

### 次回対応
- ユーザーに実際の動作（保存ボタン押下後の通知内容、コンソールログ）を確認してもらう
- 必要に応じて保存先パスの設定機能を追加

## 追加対応: エクスプローラに _out ディレクトリを表示 (2025-11-08 16:00)

ユーザーから「保存されていました。ただし、エクスプローラで"_out"が見えません。エクスプローラでは実行フォルダ配下を参照できるようにしてください。」との要望を受け、_out ディレクトリの可視化を実装。

### 実装内容

#### 1. バックエンド: 出力ファイル一覧取得機能 (workspace.ts:435-452)
```typescript
export const listOutputFiles = async (): Promise<string[]> => {
  const paths = resolveWorkspacePaths();
  try {
    const entries = await fs.readdir(paths.outputDir, { withFileTypes: true });
    const jsonFiles = entries
      .filter((entry) => entry.isFile() && entry.name.endsWith('.json'))
      .map((entry) => entry.name)
      .sort();
    return jsonFiles;
  } catch (error) {
    // ENOENT時は空配列を返す
    if ((error as NodeJS.ErrnoException)?.code === 'ENOENT') {
      return [];
    }
    throw error;
  }
};
```

#### 2. IPCハンドラ登録 (main.ts:164-168)
```typescript
ipcMain.handle('workspace:listOutputFiles', async () => {
  const files = await listOutputFiles();
  logMessage('info', `出力ファイル一覧を取得しました: ${files.length}件`);
  return files;
});
```

#### 3. Preload API追加 (preload.ts:56, 83)
- 型定義: `listOutputFiles: () => Promise<string[]>`
- 実装: `ipcRenderer.invoke('workspace:listOutputFiles')`

#### 4. 型定義追加 (global.d.ts:32)
```typescript
listOutputFiles: () => Promise<string[]>;
```

#### 5. フロントエンド状態管理 (App.tsx)
- **状態追加** (255-256行): `const [outputFiles, setOutputFiles] = useState<string[]>([]);`
- **初期化処理** (589-620行): `Promise.all`で _input と _out の両方のファイル一覧を取得
- **更新用コールバック** (639-653行): 保存後にファイル一覧を再取得する `refreshFileList()`
- **保存後の更新** (1004-1005行): `await refreshFileList();` を呼び出し

#### 6. UI実装 (App.tsx:1662-1682)
```tsx
<li role="treeitem" aria-expanded="true">
  📁 _out
  <ul role="group">
    {outputFiles.length === 0 ? (
      <li role="treeitem" className="sidebar__tree-empty">
        出力ファイルがありません
      </li>
    ) : (
      outputFiles.map((file) => (
        <li
          key={file}
          role="treeitem"
          className="sidebar__tree-file"
          title={`保存済み: ${file}`}
        >
          📄 {file}
        </li>
      ))
    )}
  </ul>
</li>
```

### 動作
1. アプリ起動時に _input と _out のファイル一覧を取得
2. エクスプローラに「📁 _out」セクションを表示
3. 保存済みファイルを「📄 ファイル名」形式で一覧表示
4. ファイルが無い場合は「出力ファイルがありません」と表示
5. 保存ボタン押下時に自動的にファイル一覧を更新

### 技術的特徴
- **エラーハンドリング**: _out ディレクトリが存在しない場合は空配列を返す
- **リアルタイム更新**: 保存成功後に即座にエクスプローラを更新
- **並列処理**: `Promise.all`で _input と _out を同時取得し、パフォーマンスを最適化
- **型安全性**: main/preload/renderer全てで TypeScript 型定義を完備

### 実装完了
- TypeScript型チェック: ✅ 通過
- P2-22a~P2-22b: ✅ 完全実装
- _out ディレクトリ可視化: ✅ 完了

## 追加対応: _outディレクトリからのファイル読み込み機能 (2025-11-08 16:30)

ユーザーから「"_out"フォルダのファイルも、"_input"フォルダと同様に、ダブルクリックで開けるようにして」との要望を受け、以下を実装。

### フォルダの使い分け仕様
- **_input**: ダブルクリックでファイルを開き編集できるが、編集結果は _out へ保存
- **_out**: ダブルクリックでファイルを開き編集でき、同名で保存可能。trace_* ファイルも _out から読み出す

### 実装内容

#### 1. バックエンド: _outディレクトリからの読み込み機能 (workspace.ts:493-531)
```typescript
export const loadOutputFile = async (fileName: string): Promise<WorkspaceSnapshot | null> => {
  const paths = resolveWorkspacePaths();
  if (fileName.includes('/') || fileName.includes('\\') || fileName.includes('..')) {
    console.warn('[workspace] invalid file name, rejecting:', fileName);
    return null;
  }

  const filePath = path.join(paths.outputDir, fileName);
  try {
    const raw = await fs.readFile(filePath, 'utf8');
    const parsed = JSON.parse(raw);
    if (isWorkspaceSnapshot(parsed)) {
      return parsed;
    }
    console.warn('[workspace] invalid card file structure:', fileName);
    return null;
  } catch (error) {
    if ((error as NodeJS.ErrnoException)?.code === 'ENOENT') {
      console.warn('[workspace] card file not found:', fileName);
      return null;
    }
    console.error('[workspace] failed to load card file:', fileName, error);
    throw error;
  }
};
```

#### 2. traceファイルの読み込み先を_outに変更 (workspace.ts:555, 565)
- `loadTraceFile` が `paths.inputDir` ではなく `paths.outputDir` から trace_*.json ファイルを検索するように変更
- これにより、保存されたカードファイルと同じディレクトリからトレーサビリティ情報を読み込める

#### 3. IPCハンドラ追加 (main.ts:182-191)
```typescript
ipcMain.handle('workspace:loadOutputFile', async (_event, fileName: string) => {
  logMessage('info', `出力ファイルを読み込みます (_out): ${fileName}`);
  const snapshot = await loadOutputFile(fileName);
  if (snapshot) {
    logMessage('info', `出力ファイルを読み込みました: ${fileName} (${snapshot.cards.length}枚)`);
  } else {
    logMessage('warn', `出力ファイルの読み込みに失敗しました: ${fileName}`);
  }
  return snapshot;
});
```

#### 4. Preload API追加 (preload.ts:60, 87)
- 型定義: `loadOutputFile: (fileName: string) => Promise<WorkspaceSnapshot | null>`
- 実装: `ipcRenderer.invoke('workspace:loadOutputFile', fileName)`

#### 5. 型定義追加 (global.d.ts:34)
```typescript
loadOutputFile: (fileName: string) => Promise<WorkspaceSnapshot | null>;
```

#### 6. フロントエンド実装 (App.tsx)
- **handleLoadOutputFile** (827-934行): _out ディレクトリからファイルを読み込むハンドラ
  - handleLoadCardFile とほぼ同じロジック
  - エラーメッセージとログで「出力ファイル」と明示
  - 未保存変更の確認ダイアログも実装

- **UI更新** (1809-1817行): _out ディレクトリのファイルにダブルクリックハンドラを追加
  ```tsx
  <li
    onDoubleClick={() => handleLoadOutputFile(file)}
    onKeyDown={(event) => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        void handleLoadOutputFile(file);
      }
    }}
    tabIndex={0}
    title={`ダブルクリックして ${file} を読み込む (_out)`}
  >
    📄 {file}
  </li>
  ```

### 動作フロー
1. **_inputからの読み込み**: `handleLoadCardFile` → `loadCardFile` (_input/) → 編集 → `saveCardFile` (_out/)
2. **_outからの読み込み**: `handleLoadOutputFile` → `loadOutputFile` (_out/) → 編集 → `saveCardFile` (_out/) (同名で上書き)
3. **traceファイル**: トレーサビリティパネルが2つのカードファイルを開いたとき、_out/ 配下の trace_*.json を自動検索・読み込み

### 技術的特徴
- **パストラバーサル対策**: ファイル名に `/`, `\`, `..` が含まれていないことを確認
- **エラーハンドリング**: ファイルが存在しない場合は null を返し、その他のエラーはログ出力
- **一貫性**: loadCardFile と同じ構造でコードの可読性と保守性を維持
- **型安全性**: main/preload/renderer 全てで TypeScript 型定義を完備

### 実装完了
- TypeScript型チェック: ✅ 通過
- 本番ビルド: ✅ 成功
- _out ファイルのダブルクリック読み込み: ✅ 完了
- trace ファイルの _out からの読み込み: ✅ 完了

### カード一覧スクロール挙動の再検証 (2025-11-08)
- 追加調査で、`panels__body` (`src/renderer/styles.css:188-196`) が `display: block` のままなため、直下の `SplitContainer` が自らの高さを確定できず、カード枚数に応じて親が伸びてしまうことを確認。結果として `.panel-cards` の `overflow-y-auto` が効かず、ツールバーごと押し出されていた。
- `panels__body` をフレックスコンテナ化 (`@apply flex flex-1 min-h-0 overflow-hidden`) し、分割ノード (`split-leaf`/`split-container`) を `flex` アイテムとして 100% 高さで拘束。さらに `split-node` (`src/renderer/styles.css:213-217`) の `h-full` を明示して、タブバー＋ツールバー＋カード一覧の縦フレックスが常にビューポート内で完結するようにした。
- これにより、カード枚数が多くてもカード一覧領域のみが独立スクロールし、タブバー／ツールバー／ログ領域は設計書 `doc/user_interface_design.md:70-112` に記載の固定表示仕様どおりに保たれる。

### カード一覧スクロール領域の再設計 (2025-11-08)
- 問題分析: ドキュメント指摘どおりカード一覧が独立スクロールになっておらず、画面全体がスクロールしていた。DOM階層を調査したところ、`workspace` -> `workspace__content` -> `panels` -> `SplitContainer` -> `split-node` の各レイヤーが `min-height: 0` や `overflow-hidden` を持たず、子要素の高さに引きずられて親コンテナ全体が伸長していることが原因と判明。単に `panel-cards` に CSS を当てるだけでは親要素が高さ制約を持たないため効果がなかった。
- 対策: レイアウトを根本から見直し、以下を実施。
  1. `workspace` / `workspace__content` / `panels` をすべて `overflow-hidden` + `h-full` + `flex` 化し、グリッド行の高さを固定したまま内部スクロールを許容。
  2. `panels__body` ラッパーを新設して `SplitContainer` 全体に `min-h-0`/`overflow-hidden` を適用し、カードパネル領域が常に自分のグリッドセル内に収まるようにした。
  3. `SplitContainer` 側では既存の `split-node`/`split-container` の `flex-1` 設定と組み合わせることで、各 `CardPanel` の `panel-cards` に設定済みの `overflow-y-auto` が正しく機能するようになった。
- これにより大量カードでもカード一覧だけに垂直スクロールが表示され、ツールバーやログエリアは固定表示のままとなる。

### ビューポート固定と split-leaf 再調整 (2025-11-08 PM)
- 追加で `body` が `overflow: auto` のままだと `app-shell` が `min-h-screen` によって無制限に伸び、カード枚数が増えるとウィンドウ全体がスクロールしてしまうことを確認。`body` に `overflow-hidden` を設定し、`app-shell` を `h-screen min-h-0`、`workspace` を `h-full` に変更してビューポート内に完全拘束するよう調整。
- `SplitContainer` の葉ノードに `split-leaf__viewport` を追加し、`CardPanel` には `flex-1 h-full` を適用することで、タブバー/ツールバー/カード一覧の縦フレックス構造が常に葉ノード内に収まり、`panel-cards` の `overflow-y-auto` だけがスクロールを担うようになった。
- これにより動作ログ領域が再び伸びることなく、分割ノードごとのスクロールバーではなくカード一覧エリア単体にスクロールバーが表示され、ユーザ要求どおりの挙動を再現できた。
