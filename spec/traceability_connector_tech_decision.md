# トレーサビリティコネクタ技術選定書

## 1. 概要
本文書は、「水平分割したパネル間でトレーサビリティコネクタを描画するUI」の実現方法について、SVG方式とCanvas API方式を比較検討し、技術選定を行った結果をまとめたものである。

## 2. 要件

### 2.1 機能要件

- 水平分割された隣り合った左右のパネル間でカード同士を接続する線（コネクタ）を描画
- コネクタは以下の情報を視覚的に表現:
  - 方向性（片方向/双方向/無方向）
  - 関係性の種類（trace/refines/tests/duplicates等）
  - 選択状態（ホバー/選択時の強調表示）
- Bézier曲線を使用した自然な曲線描画
- カードの移動・スクロールに追従

### 2.2 非機能要件

- **性能要件**: 同時に1000本以上のコネクタが存在する状況でも、移動操作に追従できること
- **操作性**: ホバー、クリック、選択などのインタラクティブ操作をサポート
- **保守性**: コードの可読性・保守性が高いこと
- **拡張性**: 将来的な機能追加に対応しやすいこと

## 3. 技術比較

### 3.1 SVG方式

#### 3.1.1 技術概要
SVG（Scalable Vector Graphics）を使用してコネクタを描画する方式。各コネクタは`<path>`または`<line>`要素として DOM に追加される。

#### 3.1.2 メリット

1. **DOM要素として扱える**
   - ホバー、クリック、選択などのインタラクティブ操作が標準のDOMイベントで実装可能
   - デバッグツール（Chrome DevTools等）で要素を検査・確認可能

2. **CSSスタイリングが適用可能**
   - `stroke-dasharray`で破線・点線を表現
   - `stroke-width`で線の太さを制御
   - `stroke`で色を指定
   - CSS transitionでアニメーション効果を実現

3. **Reactとの統合が容易**
   - JSX で`<svg>`要素を記述可能
   - React コンポーネントとして再利用可能
   - 状態管理（Zustand等）との連携が直感的

4. **アクセシビリティ**
   - スクリーンリーダー対応が可能
   - `aria-label`等で意味情報を付与可能

5. **ベクターベース**
   - 拡大縮小しても画質が劣化しない
   - ブラウザが自動でレンダリングを最適化 

#### 3.1.3 デメリット

1. **大量のDOM要素によるパフォーマンス低下**
   - 1000本以上のコネクタを描画する場合、DOM要素が増加
   - リフロー/リペイントのコストが高い

2. **スクロール/移動時の再描画コスト**
   - カード位置の変更に伴い、多数の`<path>`要素の`d`属性を更新
   - 頻繁な更新はパフォーマンスに影響

#### 3.1.4 最適化手法

以下の最適化により、1000本以上のコネクタでも実用的なパフォーマンスを実現可能:

1. **仮想化（Virtualization）**
   - 表示範囲外のコネクタは描画しない
   - スクロール時に動的に描画対象を切り替え

2. **メモ化（Memoization）**
   - `useMemo`でコネクタのパス計算結果をキャッシュ
   - `React.memo`でコンポーネントの再レンダリングを抑制

3. **バッチ更新**
   - `requestAnimationFrame`を使用して描画更新をまとめる
   - 複数のコネクタ更新を1フレームで処理

4. **CSS Transforms**
   - `transform`プロパティを使用してGPUアクセラレーションを活用
   - `will-change`プロパティでブラウザにヒントを提供

5. **イベントデリゲーション**
   - 個別のコネクタではなく、親SVG要素でイベントをハンドリング
   - ヒットテスト（どのコネクタがクリックされたか）は座標計算で実装

### 3.2 Canvas API方式

#### 3.2.1 技術概要
Canvas APIを使用してコネクタをビットマップとして描画する方式。`<canvas>`要素上に直接描画を行う。

#### 3.2.2 メリット

1. **高速な描画**
   - DOM要素を作成しないため、大量の描画が高速
   - 1フレームで全コネクタを再描画可能

2. **メモリ効率**
   - DOM要素を保持しないため、メモリ使用量が少ない

3. **スクロール/移動時の再描画が高速**
   - `clearRect()`で全体をクリアし、必要な部分のみ再描画

#### 3.2.3 デメリット

1. **インタラクティブ操作の実装コスト**
   - ホバー、クリック時のヒットテストを自前で実装
   - マウス座標からどのコネクタがクリックされたかを計算

2. **スタイリングの複雑さ**
   - CSSではなくCanvas APIでスタイル指定
   - 破線・点線は`setLineDash()`で実装

3. **Reactとの統合が複雑**
   - `useRef`でCanvas要素を取得
   - `useEffect`内で描画処理を実行
   - 状態変更時に手動で再描画

4. **アクセシビリティ**
   - スクリーンリーダー対応が困難
   - ビットマップのため、意味情報を付与しにくい

5. **デバッグの困難さ**
   - DOM要素として検査できない
   - 描画結果をビジュアルで確認するしかない

### 3.3 ハイブリッドアプローチ
SVGとCanvasを組み合わせる方式も考えられる:

- **バックグラウンド描画**: Canvas で非アクティブなコネクタを描画
- **フォアグラウンド描画**: SVG でホバー/選択中のコネクタを描画

**メリット**:
- Canvasの高速性とSVGのインタラクティブ性を両立

**デメリット**:
- 実装が複雑化
- 2つの描画システムを管理する必要

## 4. 技術選定

### 4.1 選定結果

**SVG方式（最適化付き）** を採用する。

### 4.2 選定理由

1. **開発効率**
   - ReactとSVGの統合が容易で、開発速度が速い
   - 既存のReactエコシステム（コンポーネント、フック）を活用可能

2. **UI要件との適合性**
   - ホバー、選択、スタイルカスタマイズなどの要件を満たしやすい
   - 仕様書で要求されるインタラクティブ動作をシンプルに実装可能

3. **保守性**
   - DOM要素として扱えるため、デバッグや保守が容易
   - CSSでスタイルを管理できるため、デザイン変更に柔軟に対応

4. **段階的最適化**
   - 初期実装はシンプルに、パフォーマンス問題が発生した場合に最適化を追加
   - 仮想化、メモ化などの最適化手法で1000本以上のコネクタに対応可能

5. **アクセシビリティ**
   - スクリーンリーダー対応が可能
   - WCAG 2.1 AA レベルの準拠を目指せる

### 4.3 実装戦略

#### 4.3.1 フェーズ1: 基本実装

1. **コネクタコンポーネントの作成**
   ```tsx
   <ConnectorLayer>
     {visibleConnectors.map(conn => (
       <Connector key={conn.id} {...conn} />
     ))}
   </ConnectorLayer>
   ```

2. **Bézier曲線の生成**
   - `<path>` 要素の `d` 属性で曲線を定義
   - 始点・終点から制御点を自動計算

3. **スタイル適用**
   - CSS classes で関係性の種類（trace/refines等）をスタイリング
   - ホバー/選択状態を `:hover` と `aria-selected` で表現

#### 4.3.2 フェーズ2: 最適化

1. **仮想化の導入**
   - 表示範囲（viewport）を計算
   - 範囲外のコネクタは描画しない

2. **メモ化の適用**
   - `useMemo` でパス計算をキャッシュ
   - `React.memo` でコンポーネント再レンダリングを抑制

3. **バッチ更新**
   - `requestAnimationFrame` で描画更新をまとめる

#### 4.3.3 フェーズ3: パフォーマンス測定

1. **ベンチマーク作成**
   - 100本、500本、1000本、2000本のコネクタでパフォーマンスを測定
   - FPS（Frames Per Second）を計測

2. **プロファイリング**
   - Chrome DevTools Performance タブでボトルネックを特定
   - 必要に応じて追加最適化

### 4.4 将来的な拡張性

パフォーマンスが要件を満たせない場合の代替案:

1. **Canvas への切り替え**
   - SVG実装を残したまま、Canvas版を並行開発
   - 設定で切り替え可能にする

2. **WebGL/ライブラリの導入**
   - Pixi.js、Three.js等のWebGLライブラリを検討
   - 超大規模（10,000本以上）のコネクタに対応

3. **ハイブリッドアプローチ**
   - バックグラウンド（Canvas） + フォアグラウンド（SVG）
   - 最適なバランスを見つける

## 5. 実装詳細

### 5.1 コンポーネント構成

```
TraceabilityConnectorLayer
├── ConnectorCanvas (SVG container)
│   ├── Connector (individual path element)
│   │   ├── path (Bézier curve)
│   │   └── defs (markers for arrows)
│   └── ...
└── InteractionLayer (event handling)
```

### 5.2 データフロー

1. **トレーサビリティ情報の取得**
   - Zustand ストアからトレース関係を取得
   - 左右パネルのカード位置情報を取得

2. **コネクタ座標の計算**
   - 各カードの接合点（左端/右端）座標を計算
   - スクロール位置を考慮

3. **Bézier曲線パスの生成**
   - 始点・終点から制御点を計算
   - SVG path の `d` 属性文字列を生成

4. **描画**
   - 仮想化: 表示範囲内のコネクタのみ描画
   - メモ化: 変更のないコネクタは再計算しない

### 5.3 パフォーマンス目標

| コネクタ数 | 初期描画時間 | スクロール時FPS | 目標 |
|-----------|-------------|----------------|------|
| 100       | < 50ms      | > 60 FPS       | ✓    |
| 500       | < 200ms     | > 30 FPS       | ✓    |
| 1000      | < 500ms     | > 24 FPS       | ✓    |
| 2000      | < 1000ms    | > 15 FPS       | 検討  |

## 6. リスクと緩和策

### 6.1 リスク

1. **パフォーマンス不足**
   - 1000本以上のコネクタで要件を満たせない可能性
 
2. **ブラウザ互換性**
   - 古いブラウザでSVG描画が遅い可能性
 
3. **複雑な曲線計算**
   - Bézier曲線の制御点計算が予想以上に複雑
 
### 6.2 緩和策
 
1. **段階的最適化**
   - 基本実装 → プロファイリング → 最適化のサイクル
   - 必要に応じてCanvas等への切り替えを検討
 
2. **ブラウザ要件の明示**
   - サポートブラウザを明示（Chrome/Edge/Firefox最新版）
   - Electronアプリのため、特定Chromiumバージョンに依存
 
3. **既存ライブラリの活用**
   - `d3-shape`等の曲線生成ライブラリを検討
   - 実績のあるアルゴリズムを活用
 
## 7. 結論
 
SVG方式（最適化付き）を採用することで、以下を実現する:
 
- 開発効率と保守性の向上
- UI要件への柔軟な対応
- 段階的な最適化による性能改善
- 将来的な拡張性の確保
 
初期実装では基本機能を実現し、パフォーマンス測定を経て必要な最適化を追加する。要件を満たせない場合は、Canvas方式やハイブリッドアプローチへの移行を検討する。
 
---
 
**作成日**: 2025-11-03
**作成者**: Claude (Anthropic)
**バージョン**: 1.0